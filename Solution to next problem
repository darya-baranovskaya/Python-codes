Над ареной огромного спортивного комплекса Независимого Главного Университета (НГУ) решили построить
перекрытие. Перекрытие будет построено по клеевой технологии и состоять из склеенных друг с другом блоков. 
Блок представляет собой легкий прямоугольный параллелепипед. Два блока можно склеить, если они 
соприкасаются перекрывающимися частями боковых граней ненулевой площади.

НГУ представил план комплекса, имеющий вид прямоугольника размером W на L. При этом один из углов 
прямоугольника находится в начале системы координат, а другой имеет координаты (W, L). Стены 
комплекса параллельны осям координат.

Подрядчики известили НГУ, что они готовы к определенному сроку изготовить блоки и установить их.
Для каждого блока фиксировано место его возможного монтажа, совпадающее по размерам с этим блоком.
Места выбраны так, что ребра блоков параллельны осям координат. Места монтажа блоков не пересекаются.
По техническим условиям перекрытие должно состоять из такого набора склеенных блоков, который содержит
сплошной горизонтальный слой ненулевой толщины. Торопясь ввести комплекс в эксплуатацию, НГУ решил 
построить перекрытие из минимально возможного числа блоков.
Требуется написать программу, которая позволяет выбрать минимальное число блоков, которые, 
будучи установленными на указанных подрядчиками местах, образуют перекрытие, либо определить, 
что этого сделать невозможно. Высота, на которой образуется перекрытие, не имеет значения.

import copy
n, w, l = map(int, input().split())
wl = w * l
blocks = []
startEnd = []
for i in range(n):
    x1, y1, z1, x2, y2, z2 = map(int, input().split())
    now = [z1, z2, y2 - y1, x2 - x1]
    startEnd.append([z1, 0, i])
    startEnd.append([z2, 1, i])
    blocks.append(now)
startEnd.sort()
num = 0
sq = 0
setNow = set()
small = 100000000000
setAnsw = set()
for i in range(n + 1):
    if (startEnd[i][0] > startEnd[0][0]):
        break
    sq += blocks[startEnd[i][2]][3] * blocks[startEnd[i][2]][2]
    setNow.add(startEnd[i][2])
    num += 1
if (sq == wl):
    if (num <= small):
        small = num
        setAnsw = setNow.copy()
i = num
while i < len(startEnd):
    high = startEnd[i][0]
    while i < 2 * n and startEnd[i][0] == high:
        if (startEnd[i][1] == 1):
            setNow.remove(startEnd[i][2])
            sq -= blocks[startEnd[i][2]][3] * blocks[startEnd[i][2]][2]
            num -= 1
        else:
            setNow.add(startEnd[i][2])
            sq += blocks[startEnd[i][2]][3] * blocks[startEnd[i][2]][2]
            num += 1
        i += 1
    if (sq == wl):
        if (num <= small):
            small = num
            setAnsw = setNow.copy()
if (small == 100000000000):
    print('NO')
else:
    print('YES')
    print(small)
    print('\n'.join(map(lambda x: str(x + 1), sorted(setAnsw))))

